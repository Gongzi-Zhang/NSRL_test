#!/usr/bin/env python3
# coding: utf-8

'''
extract mip values from a histogram 
    * input: run_hist.root
    * output: run_mip.json
'''

import os
import sys
import uproot
import numpy as np
from scipy.signal import find_peaks, savgol_filter
import json
from utilities import *
import zdc

def getMIP(hist_file: str, out_file = "mip.json"):
    if not os.path.exists(hist_file):
        logger.fatal("File deosn't exist: {hist_file}")
        exit(4)
        # Step 1: Load the histogram data from a ROOT file
    fin = uproot.open(hist_file)

    mip = {'HG': {}}
    for ch in range(0, zdc.config['nCAENChannels']):
        histogram = fin[f"Ch_{ch}_HG"]  # Replace with your histogram name

        # Extract bin contents and edges
        values = histogram.values()  # Bin contents (counts)
        edges = histogram.axis().edges()    # Bin edges
        bin_centers = (edges[:-1] + edges[1:]) / 2  # Calculate bin centers

        # Step 2: Smooth the data to reduce noise
        window_length = 11  # Must be odd, adjust based on noise level
        polyorder = 2      # Polynomial order for smoothing
        smoothed_values = savgol_filter(values, window_length, polyorder)

        # Step 3: Detect peaks in the smoothed spectrum
        peaks, properties = find_peaks(smoothed_values, prominence=1, height=1)

        # Step 4: Detect dips (local minima) between peaks
        inverted_values = -smoothed_values
        dips, _ = find_peaks(inverted_values, prominence=1)

        # Step 5: Identify the pedestal and MIP peaks
        if len(peaks) < 1:
            logger.warning(f"No peaks found in channel {ch}")
            mip['HG'][ch] = [0, 0, 0]
            continue

        # Pedestal peak is the first significant peak
        pedestal_peak_idx = peaks[0]
        pedestal_peak_x = bin_centers[pedestal_peak_idx]

        # Find the dip closest to 2000
        if len(dips) > 0:
            dip_distances = np.abs(bin_centers[dips] - 2000)
            closest_dip_idx = dips[np.argmin(dip_distances)]  # Index of the dip closest to 2000
        else:
            logger.warning(f"No dips found in channel {ch}!")
            mip['HG'][ch] = [0, 0, 0]
            continue

        # MIP peak is the fist peak after the dip
        peaks_after_dip = peaks[peaks > closest_dip_idx]
        if len(peaks_after_dip) > 0:
            mip_peak_idx = peaks_after_dip[0]  # First peak after the dip

        mip_peak_x = bin_centers[mip_peak_idx]

        # Step 6: Calculate the distance between the pedestal and MIP peaks
        distance = mip_peak_x - pedestal_peak_x

        # Step 7: Calculate the FWHM of the MIP peak
        # Find the maximum height of the MIP peak
        mip_peak_height = smoothed_values[mip_peak_idx]
        half_max = mip_peak_height / 2

        # Find the indices where the smoothed values cross the half-maximum on either side
        # Left side: search from the start to the MIP peak
        left_idx = np.where(smoothed_values[:mip_peak_idx] <= half_max)[0]
        if len(left_idx) > 0:
            left_idx = left_idx[-1]  # Last index before the peak where value <= half_max
        else:
            left_idx = 0  # Fallback to the start if no crossing is found

        # Right side: search from the MIP peak to the end
        right_idx = np.where(smoothed_values[mip_peak_idx:] <= half_max)[0]
        if len(right_idx) > 0:
            right_idx = mip_peak_idx + right_idx[0]  # First index after the peak where value <= half_max
        else:
            right_idx = len(smoothed_values) - 1  # Fallback to the end if no crossing is found

        # Right side interpolation
        if smoothed_values[right_idx] == half_max:
            right_x = bin_centers[right_idx]
        else:
            x1, x2 = bin_centers[right_idx - 1], bin_centers[right_idx]
            y1, y2 = smoothed_values[right_idx - 1], smoothed_values[right_idx]
            right_x = x1 + (half_max - y1) * (x2 - x1) / (y2 - y1)

        # Linear interpolation for more precise crossing points
        # Left side interpolation
        if smoothed_values[left_idx] == half_max:
            left_x = bin_centers[left_idx]
        else:
            left_x = mip_peak_x - (right_x - mip_peak_x)

        # Calculate the FWHM
        fwhm = right_x - left_x
        mip['HG'][ch] = [mip_peak_x, pedestal_peak_x, fwhm]

    with open(out_file, 'w') as f:
        json.dump(mip, f, indent=2, separators=(',', ': '))

def usage():
    print(sys.argv[0] + ' -l run_list.txt [-p prefix] [-d output_dir] ')
    print('\t-h: print this help message')
    print('\t-r: input hist root file')
    print('\t-p: output file')

if __name__ == '__main__':
    # read in command line arguments
    i=1
    histFile = ''
    outFile = '.'
    while i<len(sys.argv):
        if '-h' == sys.argv[i]:
            usage()
            exit(0)
        elif '-r' == sys.argv[i]:
            histFile = sys.argv[i+1]
            i += 1
        elif '-o' == sys.argv[i]:
            outFile = sys.argv[i+1]
            i += 1
        else:
            logger.error(f'Unknown argument {sys.argv[i]}')
            exit(1)
        i += 1

    getMIP(histFile, outFile)

